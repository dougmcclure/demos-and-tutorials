#
# Simple logstash v1.3.x configuration for consuming Netcool/OMNIbus events using
# a socket gateway, sent to SCALA v1.2.x in a CSV format via the SCALA logtash output plugin, 
# processed via a DSV based annotation pack
#
# a little rsyslog thrown in for good measure
#

input { 
  
# this is the tcp input for your socket GW from OMNIbus
  
	tcp {
		type => "netcool event stream"
		format => "plain"
		port => 1234
		data_timeout => -1
		tags => ["netcool-raw"]
		} #end tcp

# lets suck in some rsyslog feeds as well
		
	tcp {
		type => "rsyslog-raw"
		format => "plain"
		port => 5144
		data_timeout => -1
		tags => ["rsyslog-raw"]
	} #end tcp
	
} #end inputs

filter {
	
#RSYSLOG FILTERS

# I'm using a rsyslog formatter that puts the output messages in CSV format - KISS!
	
if "rsyslog-raw" in [tags] {
    csv {
		#"2014-01-21T18:23:39.374905-05:00,host=blah,relayHost=blah,tag=root:,programName=root,procid=,facility=user,sev=notice,appName=root,msg= hello"
		columns => ["SourceTimestamp","SourceHost","RelayHost","Tags","ProgramName","ProcessID","Facility","Severity","ApplicationName","LogMessage"]
		add_field => ["scalaFields", "SourceTimestamp"]
    	add_field => ["scalaFields", "SourceHost"]
    	add_field => ["scalaFields", "RelayHost"]
		add_field => ["scalaFields", "Tags"]
		add_field => ["scalaFields", "ProgramName"]
    	add_field => ["scalaFields", "ProcessID"]
		add_field => ["scalaFields", "Facility"]
		add_field => ["scalaFields", "Severity"]
		add_field => ["scalaFields", "ApplicationName"]
		add_field => ["scalaFields", "LogMessage"]
		add_tag => ["rsyslog-csvd"]
    	remove_tag => ["rsyslog-raw"]
	} #end csv
 } #end conditional	

# sets SCALA's data source host and path values 
 
if "rsyslog-csvd" in [tags] {
	mutate {
		replace => [ "host", "logstash-syslog-feed", "path", "logstash-syslog-feed" ]
		add_tag => [ "rsyslog-final" ]
		remove_tag => ["rsyslog-csvd"]
		} #end mutate
	} #end conditional

#NETCOOL FILTERS

#filter out events that are breaking clean CSV processing in next step (eg slot shifting, bogus characters, non-timestamp in timestamp slot)

if "netcool-raw" in [tags] {
	grep
		{ 
		match => [ "message", ".*\${DestinationContext.ComponentName}.* | .*MS_Offline.* | .*Micromuse-ProbeWatch.* | .*XAException.* "] 
		negate => true
		add_tag => [ "netcool-drop" ]
		remove_tag => [ "netcool-raw" ]
		} #end grep
} # end conditional

#customize based on the fields you're sending from OMNIBus socket gateway map file, after you have unique fields you can then take other actions on field level in your filters

if "netcool-drop" in [tags] {
    csv {
		columns => ["Identifier","Serial","timestamp","FirstOccurrence","Node","NodeAlias","Summary","Severity","Manager","Agent","AlertGroup","AlertKey","Type","Tally","Class","Grade","Location","ITMDisplayItem","ITMSitOrigin","CAM_Application_Name","CAM_Transaction_Name","CAM_SubTransaction_Name","CAM_Client_Name","CAM_Server_Name","CAM_Profile_Name","BSMAccelerator_Service","BSMAccelerator_Function","TASPAlgorithmInstanceName","TASPAlgorithmName","TASPAnomalousMetricGroups","TASPAnomalousMetrics","TASPAnomalousResources","TASPAnomalyTimestamp","TASPCorrelationId","TASPInstanceIdentifier","TASPMetricGroupNameList","TASPMetricInformation","TASPMetricNameList","TASPMetricNodeList","TASPMetricResourceNameList","TASPMetricResourceTypeList","TASPMetricScoreList","TASPMetricValueList","TASPParentIdentifier","TASPQuantifier","TASPUpdateTime"]
		add_field => ["scalaFields", "Identifier"]
    	add_field => ["scalaFields", "Serial"]
    	add_field => ["scalaFields", "timestamp"]
		add_field => ["scalaFields", "FirstOccurrence"]
		add_field => ["scalaFields", "Node"]
    	add_field => ["scalaFields", "NodeAlias"]
		add_field => ["scalaFields", "Summary"]
		add_field => ["scalaFields", "Severity"]
		add_field => ["scalaFields", "Manager"]
		add_field => ["scalaFields", "Agent"]
		add_field => ["scalaFields", "AlertGroup"]
		add_field => ["scalaFields", "AlertKey"]
		add_field => ["scalaFields", "Type"]
		add_field => ["scalaFields", "Tally"]
		add_field => ["scalaFields", "Class"]
		add_field => ["scalaFields", "Grade"]
		add_field => ["scalaFields", "Location"]
		add_field => ["scalaFields", "ITMDisplayItem"]
		add_field => ["scalaFields", "ITMSitOrigin"]
		add_field => ["scalaFields", "CAM_Application_Name"]
		add_field => ["scalaFields", "CAM_Transaction_Name"]
		add_field => ["scalaFields", "CAM_SubTransaction_Name"]
		add_field => ["scalaFields", "CAM_Client_Name"]
		add_field => ["scalaFields", "CAM_Server_Name"]
		add_field => ["scalaFields", "CAM_Profile_Name"]
		add_field => ["scalaFields", "BSMAccelerator_Service"]
		add_field => ["scalaFields", "BSMAccelerator_Function"]
		add_field => ["scalaFields", "TASPAlgorithmInstanceName"]
		add_field => ["scalaFields", "TASPAlgorithmName"]
		add_field => ["scalaFields", "TASPAnomalousMetricGroups"]
		add_field => ["scalaFields", "TASPAnomalousMetrics"]
		add_field => ["scalaFields", "TASPAnomalousResources"]
		add_field => ["scalaFields", "TASPAnomalyTimestamp"]
		add_field => ["scalaFields", "TASPCorrelationId"]
		add_field => ["scalaFields", "TASPInstanceIdentifier"]
		add_field => ["scalaFields", "TASPMetricGroupNameList"]
		add_field => ["scalaFields", "TASPMetricInformation"]
		add_field => ["scalaFields", "TASPMetricNameList"]
		add_field => ["scalaFields", "TASPMetricNodeList"]
		add_field => ["scalaFields", "TASPMetricResourceNameList"]
		add_field => ["scalaFields", "TASPMetricResourceTypeList"]
		add_field => ["scalaFields", "TASPMetricScoreList"]
		add_field => ["scalaFields", "TASPMetricValueList"]
		add_field => ["scalaFields", "TASPParentIdentifier"]
		add_field => ["scalaFields", "TASPQuantifier"]
		add_field => ["scalaFields", "TASPUpdateTime"]
		add_tag => ["netcool-csvd"]
    	remove_tag => ["netcool-drop"]
	} #end csv
 } #end conditional

 
# set the host and path used in the SCALA data source config
 
if "netcool-csvd" in [tags] {
	mutate {
		replace => [ "host", "logstash-netcool-feed", "path", "logstash-netcool-feed" ]
		add_tag => [ "netcool-final" ]
		remove_tag => ["netcool-csvd"]
		} #end mutate
	} #end conditional
	
} #end filter

output { 

#	stdout { 
#		debug => true
#		debug_format => "json"
#		} #end stdout

# I always like a copy in case I want to analyse/replay later
	
	if "rsyslog-final" in [tags] {
	file {
		path => "/opt/logstash/rsyslog-logstash-output.log"
		} #end file
	} #end conditional
	
	if "netcool-final" in [tags] {
	file {
		path => "/opt/logstash/netcool-logstash-output.log"
		} #end file
	} #end conditional
	
# Spray to your SCALA boxes. In this case I'm sending same stream to two SCALA boxes.	
	
	if "rsyslog-final" or "netcool-final" in [tags] {
		scala_custom_eif {
			eif_config => "logstash/outputs/eif-scala1-145.conf"
			debug_log =>  "/tmp/scala/scala-logstash-scala1.log"
			debug_level => "debug"
		} #end scala1 output
    
		scala_custom_eif {
			eif_config => "logstash/outputs/eif-scala2-146.conf"
			debug_log =>  "/tmp/scala/scala-logstash-scala2.log"
			debug_level => "info"
		} #end scala2 output
    
	} #end conditional

# Turn on if you want to fire up the awesome Kibana interface
	
#	elasticsearch { 
#		embedded => true 
#		} #end elasticsearch
		
} #end outputs
